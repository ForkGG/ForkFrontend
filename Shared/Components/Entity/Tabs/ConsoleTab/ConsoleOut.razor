@using ProjectAveryFrontend.Logic.Services.Notifications
@using ProjectAveryCommon.Model.Entity.Pocos
@using ProjectAveryCommon.Model.Entity.Transient.Console
@using ProjectAveryCommon.Model.Notifications.EntityNotifications
@using ProjectAveryCommon.Model.Entity.Enums.Console
@implements IAsyncDisposable

@inject IJSRuntime _js
@inject INotificationService _notificationService
@inject ILogger<ConsoleOut> _logger

<div class="flex-1 flex flex-col console-out-container clipping">
    @*Controls*@
    <div class="flex justify-between">
        <span style="width: 60px" content=" "></span>
        <span class="text-lg text-label font-bold p-3">Console</span>
        <div class="flex gap-3 mr-5 items-center">
            <IconButton Size="23" IconSize="22" NoBackground="true" IconChar="'F'"></IconButton>
            <IconButton Size="23" IconSize="22" NoBackground="true" IconChar="'O'"></IconButton>
        </div>
    </div>

    @* Console *@
    <div class="flex-1">
        <div id="@($"consoleScrollArea{Entity?.Id}")" class="clusterize-scroll p-3 overflow-ellipsis text-text overflow-y-auto max-h-full select-text" @ref="_consoleScroller" @onscroll="OnConsoleScroll">
            <div id="@($"consoleContentArea{Entity?.Id}")" class="clusterize-content console-text" @ref="_consoleContent">
                <div class="clusterize-no-data">Loading Console...</div>
            </div>
        </div>
    </div>
</div>

@code {

    [CascadingParameter]
    public IEntity? Entity { get; set; }

    private List<ConsoleMessage> ConsoleMessages { get; set; } = new();

    private ElementReference _consoleScroller;
    private ElementReference _consoleContent;

    private bool _autoscroll = true;
    private bool _userscroll = true;

    protected override void OnInitialized()
    {
        _notificationService.Register<ConsoleAddNotification>(async notification => { await HandleNewConsoleLine(notification); });
    }


    private bool _isFirstRender = true;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_isFirstRender)
        {
            _isFirstRender = false;
    // TODO CKE initialize console with existing lines (API call)
            for (int i = 0; i < 500; i++)
            {
                ConsoleMessages.Add(new ConsoleMessage($"{Entity?.Name} Message {i}", ConsoleMessageType.UserInput));
            }
            await _js.InvokeVoidAsync("InitConsoleClusterize", ConsoleMessages.Select(ConsoleMessageToHtml).ToList(), _consoleScroller, _consoleContent);

    // Scroll to bottom
            await ScrollToBottom();
            await Task.Delay(1);
    // THE ABSOLUTE BOTTOM!!!
            await ScrollToBottom();
        }
    }

    // It is important to clean up here else we have too many Registered handlers and NullPointers in JS
    public async ValueTask DisposeAsync()
    {
        _notificationService.Unregister<ConsoleAddNotification>(this);
        await _js.InvokeVoidAsync("DestroyConsoleCluster", _consoleScroller);
    }

    private async Task HandleNewConsoleLine(ConsoleAddNotification notification)
    {
    // Skip notifications not matching the id
        if (notification.EntityId != Entity?.Id)
        {
            return;
        }
        ConsoleMessages.Add(notification.NewConsoleMessage);
        await _js.InvokeVoidAsync("AppendToConsole", ConsoleMessageToHtml(notification.NewConsoleMessage), _consoleScroller);
        StateHasChanged();
        if (_autoscroll)
        {
            await ScrollToBottom();
        }
    }

    private async Task ScrollToBottom()
    {
        _userscroll = false;
        await _js.InvokeVoidAsync("ScrollToBottom", _consoleScroller);
        _userscroll = true;
    }

    //TODO Search feature: Use the update method of clusterize to apply new css to found rows and scroll to the found results

    private async Task OnConsoleScroll()
    {
        if (_userscroll)
        {
            _autoscroll = await _js.InvokeAsync<bool>("IsScrolledToBottom", new object[] { _consoleScroller });
        }
    }

    private string ConsoleMessageToHtml(ConsoleMessage message)
    {
        string escapedMessage = message.Message.Replace("<", "&lt;").Replace("\"", "&quot;").Replace(">", "&gt;");
        string colorClass = MessageTypeToConsoleColor(message.MessageType);
        return $"<div class=\"block monospace leading-tight text-sm {colorClass}\">{escapedMessage}</div>";
    }

    private string MessageTypeToConsoleColor(ConsoleMessageType type)
    {
        switch (type)
        {
            case ConsoleMessageType.Success:
                return "text-text-green";
            case ConsoleMessageType.Warning:
                return "text-text-orange";
            case ConsoleMessageType.Error:
                return "text-text-red";
            case ConsoleMessageType.UserInput:
                return "opacity-70";
            default:
                return "";
        }
    }

}